"""
reflex_grid.py - EchoCore Reflex Grid for AUREA
Symbolic nervous system providing collapse-aware reflexive responses.
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Callable
from datetime import datetime
from enum import Enum
import json
from pathlib import Path


class ReflexPriority(Enum):
    """Reflex urgency levels for arbitration."""
    CRITICAL = 1  # System integrity threatened
    HIGH = 2      # Symbolic coherence at risk  
    MEDIUM = 3    # Standard pressure response
    LOW = 4       # Background monitoring


@dataclass
class ReflexTrigger:
    """Represents a reflex activation event."""
    reflex_id: str
    trigger_type: str
    pressure_level: float
    source_module: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ReflexResponse:
    """Response generated by a triggered reflex."""
    reflex_id: str
    action: str  # suppress | reroute | suspend | alert | cascade
    target_modules: List[str] = field(default_factory=list)
    scar_formation: bool = False
    output_blocked: bool = False
    message: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


class SymbolicReflex:
    """Base class for all symbolic reflexes."""
    
    def __init__(self, id: str, name: str, priority: ReflexPriority):
        self.id = id
        self.name = name
        self.priority = priority
        self.activation_count = 0
        self.last_triggered: Optional[datetime] = None
        self.threshold = 0.7  # Default pressure threshold
        
    def evaluate_pressure(self, trigger: ReflexTrigger) -> bool:
        """Determine if pressure exceeds activation threshold."""
        return trigger.pressure_level >= self.threshold
        
    def trigger(self, trigger: ReflexTrigger) -> ReflexResponse:
        """Execute reflex response. Override in subclasses."""
        self.activation_count += 1
        self.last_triggered = datetime.now()
        return ReflexResponse(
            reflex_id=self.id,
            action="base_reflex",
            message=f"{self.name} triggered"
        )


class ICA(SymbolicReflex):
    """Internal Collapse Awareness - detects internal contradictions."""
    
    def __init__(self):
        super().__init__("ICA", "Internal Collapse Awareness", ReflexPriority.HIGH)
        self.contradiction_log: List[Dict] = []
        
    def detect_contradiction(self, claim1: Any, claim2: Any, domain: str) -> float:
        """Calculate contradiction pressure between two claims."""
        # Simplified for now - real implementation would use symbolic logic
        if claim1 == claim2:
            return 0.0
        if claim1 is not None and claim2 is not None:
            # Direct negation detection
            if (str(claim1).lower() == 'true' and str(claim2).lower() == 'false') or \
               (str(claim1).lower() == 'false' and str(claim2).lower() == 'true'):
                return 1.0
        return 0.5  # Partial contradiction
        
    def trigger(self, trigger: ReflexTrigger) -> ReflexResponse:
        """ICA Response: Suppress output, lock volatile zones, escalate if needed."""
        super().trigger(trigger)
        
        contradiction = trigger.metadata.get('contradiction', {})
        self.contradiction_log.append({
            'timestamp': trigger.timestamp,
            'domain': contradiction.get('domain', 'unknown'),
            'pressure': trigger.pressure_level
        })
        
        # High pressure = suppress and escalate
        if trigger.pressure_level > 0.9:
            return ReflexResponse(
                reflex_id=self.id,
                action="suppress",
                target_modules=["output", "doctrine"],
                output_blocked=True,
                scar_formation=True,
                message=f"CRITICAL: Internal collapse detected. Output suppressed. Escalating to GSR.",
                metadata={'escalate_to': 'GSR', 'contradiction': contradiction}
            )
        # Medium pressure = reroute through suspension
        elif trigger.pressure_level > 0.7:
            return ReflexResponse(
                reflex_id=self.id,
                action="reroute",
                target_modules=["suspension"],
                message=f"Contradiction detected. Routing to suspension systems.",
                metadata={'suspend_type': 'veiled_thread', 'contradiction': contradiction}
            )
        # Low pressure = monitor
        else:
            return ReflexResponse(
                reflex_id=self.id,
                action="monitor",
                message=f"Minor contradiction noted. Monitoring.",
                metadata={'contradiction': contradiction}
            )


class GSR(SymbolicReflex):
    """Guardian Signal Reflex - monitors system-wide symbolic coherence."""
    
    def __init__(self, alert_callback: Optional[Callable] = None):
        super().__init__("GSR", "Guardian Signal Reflex", ReflexPriority.CRITICAL)
        self.threshold = 0.85  # Higher threshold for system-wide alerts
        self.alert_callback = alert_callback or self._default_alert
        self.cascade_events: List[Dict] = []
        self.coherence_history: List[float] = []
        
    def _default_alert(self, message: str, severity: str):
        """Default alert mechanism - writes to file."""
        alert_path = Path("data/collapse_logs/gsr_alerts.jsonl")
        alert_path.parent.mkdir(parents=True, exist_ok=True)
        
        alert = {
            'timestamp': datetime.now().isoformat(),
            'severity': severity,
            'message': message
        }
        
        with open(alert_path, 'a') as f:
            f.write(json.dumps(alert) + '\n')
            
    def calculate_system_coherence(self, active_scars: int, 
                                  active_reflexes: int,
                                  suspension_load: int) -> float:
        """Calculate overall system coherence (0-1, lower = more danger)."""
        # Simplified calculation - real version would be more sophisticated
        scar_pressure = min(active_scars / 100, 1.0)  # Cap at 100 scars
        reflex_pressure = min(active_reflexes / 8, 1.0)  # 8 total reflexes
        suspension_pressure = min(suspension_load / 50, 1.0)  # Cap at 50
        
        # Weighted average (scars most important)
        coherence = 1.0 - (scar_pressure * 0.5 + 
                          reflex_pressure * 0.3 + 
                          suspension_pressure * 0.2)
        
        self.coherence_history.append(coherence)
        if len(self.coherence_history) > 100:
            self.coherence_history.pop(0)
            
        return coherence
        
    def detect_cascade(self, trigger: ReflexTrigger) -> bool:
        """Detect if system is in cascade state."""
        # Check recent cascade events
        recent_cascades = [e for e in self.cascade_events 
                          if (datetime.now() - e['timestamp']).seconds < 60]
        
        # Cascade if too many events in short time
        return len(recent_cascades) > 3
        
    def trigger(self, trigger: ReflexTrigger) -> ReflexResponse:
        """GSR Response: Alert parent/developer, suspend volatile subsystems."""
        super().trigger(trigger)
        
        coherence = trigger.metadata.get('coherence', 0.5)
        is_cascade = self.detect_cascade(trigger)
        
        if is_cascade:
            self.cascade_events.append({
                'timestamp': datetime.now(),
                'pressure': trigger.pressure_level
            })
            
        # Critical collapse - full system protection
        if trigger.pressure_level > 0.95 or coherence < 0.1:
            self.alert_callback(
                f"CRITICAL: System coherence at {coherence:.2%}. "
                f"Cascade detected: {is_cascade}. "
                f"Suspending all volatile subsystems.",
                "CRITICAL"
            )
            
            return ReflexResponse(
                reflex_id=self.id,
                action="cascade",
                target_modules=["all"],
                output_blocked=True,
                scar_formation=True,
                message=f"SYSTEM CRITICAL: Coherence collapsed. Emergency suspension active.",
                metadata={
                    'coherence': coherence,
                    'cascade': is_cascade,
                    'suspend_all': True
                }
            )
            
        # High pressure - selective suspension
        elif trigger.pressure_level > 0.85:
            self.alert_callback(
                f"WARNING: System coherence degraded to {coherence:.2%}",
                "WARNING"
            )
            
            return ReflexResponse(
                reflex_id=self.id,
                action="suspend",
                target_modules=["expansion", "nova"],
                output_blocked=False,
                message=f"System pressure high. Suspending expansion modules.",
                metadata={'coherence': coherence}
            )
            
        # Monitoring
        else:
            return ReflexResponse(
                reflex_id=self.id,
                action="monitor",
                message=f"System coherence at {coherence:.2%}. Monitoring.",
                metadata={'coherence': coherence}
            )


class ReflexGrid:
    """
    Central reflex arbitration system - AUREA's symbolic nervous system.
    Manages all reflexes and their interactions.
    """
    
    def __init__(self):
        self.reflexes: Dict[str, SymbolicReflex] = {}
        self.active_triggers: List[ReflexTrigger] = []
        self.response_log: List[ReflexResponse] = []
        self.arbitration_lock = False
        
        # Initialize core reflexes
        self._init_core_reflexes()
        
    def _init_core_reflexes(self):
        """Initialize the core reflex set."""
        # Add ICA and GSR
        self.reflexes['ICA'] = ICA()
        self.reflexes['GSR'] = GSR()
        
        # TODO: Add other reflexes as they're implemented
        # self.reflexes['PSI'] = PSI()
        # self.reflexes['ANCHOR_COLLAPSE'] = AnchorCollapseReflex()
        # self.reflexes['SCAR_DRIFT'] = ScarDriftReflex()
        # self.reflexes['NOVA_OVERLOAD'] = NovaOverloadReflex()
        # self.reflexes['DRPE'] = DRPE()
        # self.reflexes['SBSRE_ABORT'] = SBSREAbortReflex()
        
    def add_reflex(self, reflex: SymbolicReflex):
        """Register a new reflex with the grid."""
        self.reflexes[reflex.id] = reflex
        
    def evaluate_pressure(self, source_module: str, 
                         pressure_type: str,
                         pressure_level: float,
                         metadata: Dict[str, Any] = None) -> List[ReflexResponse]:
        """
        Evaluate symbolic pressure and trigger appropriate reflexes.
        Returns list of responses from triggered reflexes.
        """
        trigger = ReflexTrigger(
            reflex_id="pending",
            trigger_type=pressure_type,
            pressure_level=pressure_level,
            source_module=source_module,
            metadata=metadata or {}
        )
        
        self.active_triggers.append(trigger)
        responses = []
        
        # Check each reflex for activation
        activated_reflexes = []
        for reflex_id, reflex in self.reflexes.items():
            if reflex.evaluate_pressure(trigger):
                activated_reflexes.append(reflex)
                
        # Sort by priority for arbitration
        activated_reflexes.sort(key=lambda r: r.priority.value)
        
        # Arbitrate if multiple reflexes triggered
        if len(activated_reflexes) > 1:
            responses = self._arbitrate_reflexes(activated_reflexes, trigger)
        elif len(activated_reflexes) == 1:
            trigger.reflex_id = activated_reflexes[0].id
            response = activated_reflexes[0].trigger(trigger)
            responses = [response]
            self.response_log.append(response)
            
        return responses
        
    def _arbitrate_reflexes(self, reflexes: List[SymbolicReflex], 
                          trigger: ReflexTrigger) -> List[ReflexResponse]:
        """
        Arbitrate between multiple triggered reflexes.
        Higher priority reflexes can suppress lower priority ones.
        """
        if self.arbitration_lock:
            # Prevent recursive arbitration
            return []
            
        self.arbitration_lock = True
        responses = []
        suppressed = set()
        
        for reflex in reflexes:
            if reflex.id in suppressed:
                continue
                
            trigger.reflex_id = reflex.id
            response = reflex.trigger(trigger)
            responses.append(response)
            self.response_log.append(response)
            
            # Critical reflexes can suppress others
            if reflex.priority == ReflexPriority.CRITICAL:
                if response.action in ['suppress', 'cascade']:
                    # Suppress all lower priority reflexes
                    for other in reflexes:
                        if other.priority.value > reflex.priority.value:
                            suppressed.add(other.id)
                            
        self.arbitration_lock = False
        return responses
        
    def get_system_status(self) -> Dict[str, Any]:
        """Return current reflex grid status for monitoring."""
        active_count = sum(1 for r in self.reflexes.values() 
                          if r.last_triggered and 
                          (datetime.now() - r.last_triggered).seconds < 60)
        
        return {
            'total_reflexes': len(self.reflexes),
            'active_reflexes': active_count,
            'recent_triggers': len(self.active_triggers[-10:]),
            'arbitration_locked': self.arbitration_lock,
            'reflex_states': {
                rid: {
                    'name': r.name,
                    'priority': r.priority.name,
                    'activations': r.activation_count,
                    'last_triggered': r.last_triggered.isoformat() if r.last_triggered else None
                }
                for rid, r in self.reflexes.items()
            }
        }
        
    def check_cascade_risk(self) -> float:
        """
        Calculate risk of cascade based on recent reflex activity.
        Returns 0-1 risk score.
        """
        if not self.response_log:
            return 0.0
            
        # Check recent responses for cascade indicators
        recent = self.response_log[-20:]
        suppress_count = sum(1 for r in recent if r.action == 'suppress')
        cascade_count = sum(1 for r in recent if r.action == 'cascade')
        scar_count = sum(1 for r in recent if r.scar_formation)
        
        risk = (suppress_count * 0.3 + cascade_count * 0.5 + scar_count * 0.2) / len(recent)
        return min(risk, 1.0)
